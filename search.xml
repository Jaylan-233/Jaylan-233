<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PreparedStatement的使用</title>
      <link href="/2023/09/06/JavaWeb/PreparedStatement%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/09/06/JavaWeb/PreparedStatement%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL注入问题"><a href="#SQL注入问题" class="headerlink" title="SQL注入问题"></a>SQL注入问题</h2><h3 id="什么是SQL注入"><a href="#什么是SQL注入" class="headerlink" title="什么是SQL注入"></a>什么是SQL注入</h3><p><strong>正常的SQL语句</strong></p><p>SELECT * FORM user WHERE name=用户名 AND password=密码;</p><p><strong>SQL经过注入之后的SQL语句</strong></p><p>SELECT * FORM user WHERE name=用户名 AND <strong>password=密码 AND 1=1</strong>;</p><blockquote><p>1=1始终成立 所以name=用户名 AND password=密码 AND 1=1相当于</p><p>name=用户名AND 1,始终成立 所以 只要用户名正确就能登录</p></blockquote><h3 id="如何避免SQL注入"><a href="#如何避免SQL注入" class="headerlink" title="如何避免SQL注入"></a>如何避免SQL注入</h3><ul><li>使用PreparedStament对象执行SQL语句</li></ul><blockquote><p>因为使用Stament对象执行时 均是通过传递字符串实现的 容易被修改</p><p>使用了PreparedStament则会对SQL进行预编译 这样就可以避免一些SQL注入问题</p></blockquote><p><strong>使用了PreparedStament对象执行SQL不一定就能避免所有的SQL注入问题</strong></p><span id="more"></span><h2 id="为什么要使用PreparedStament对象执行SQL语句"><a href="#为什么要使用PreparedStament对象执行SQL语句" class="headerlink" title="为什么要使用PreparedStament对象执行SQL语句"></a>为什么要使用PreparedStament对象执行SQL语句</h2><ul><li>能防止大部分SQL注入</li></ul><blockquote><p>将SQL进行预编译</p></blockquote><ul><li>能将SQL语句参数化</li></ul><p>使用Stament对对象时所使用的SQL语句</p><p>SELECT * FORM user WHERE id=123;</p><blockquote><p>SQL必须写完整特别是参数（这里可能就要进行拼接）</p></blockquote><p>参数化的ＳＱＬ</p><p>SELECT * FORM user WHERE id=?</p><blockquote><p>这里的？是一个参数在执行SQL之前可以进行设置</p></blockquote><ul><li>效率更高</li></ul><blockquote><p>SQL是预编译在将来的查询中能过重用</p></blockquote><h2 id="使用PreparedStament对象操作数据库代码实例"><a href="#使用PreparedStament对象操作数据库代码实例" class="headerlink" title="使用PreparedStament对象操作数据库代码实例"></a>使用PreparedStament对象操作数据库代码实例</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> TestJBDC02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 使用PreparedStatement对象操作数据库</span></span><br><span class="line"><span class="comment"> * S</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Jay lan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023/9/6 14:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJBDC02</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException {</span><br><span class="line"><span class="comment">//        加载驱动</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">//        设置连接参数</span></span><br><span class="line">        String url=<span class="string">"jdbc:mysql://127.0.0.1:3306/chapter01?useSSL=false"</span>;</span><br><span class="line">        String username=<span class="string">"root"</span>;</span><br><span class="line">        String password=<span class="string">"Xi233"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        获取数据库连接</span></span><br><span class="line">        Connection connection= DriverManager.getConnection(url,username,password);</span><br><span class="line"><span class="comment">//          编写参数化的SQL语句</span></span><br><span class="line">        String selectSql=<span class="string">"SELECT * FROM student WHERE sid=?"</span>;</span><br><span class="line"><span class="comment">//        这里的使用的是preparedStatement</span></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span>connection.prepareStatement(selectSql);<span class="comment">/*预编译SQL*/</span></span><br><span class="line"><span class="comment">//          设置SQL参数</span></span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>,<span class="string">"1"</span>);<span class="comment">/*第一个参数是参数的下标 从1开始 第二个是参数内容*/</span></span><br><span class="line"><span class="comment">//        执行SLQ语句并 获取结果集</span></span><br><span class="line">        ResultSet resultSet=preparedStatement.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        输出结果集合中的数据</span></span><br><span class="line">        System.out.println(<span class="string">"id  |  name | age | course|"</span>);</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())</span><br><span class="line">        {</span><br><span class="line">         <span class="type">int</span> id=resultSet.getInt(<span class="string">"sid"</span>);</span><br><span class="line">         String name=resultSet.getString(<span class="string">"sname"</span>);</span><br><span class="line">         <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span>resultSet.getString(<span class="string">"age"</span>);</span><br><span class="line">         String course=resultSet.getString(<span class="string">"course"</span>);</span><br><span class="line">         System.out.println(id+<span class="string">"   |"</span>+name+<span class="string">"   |"</span>+age+<span class="string">"   |"</span>+course+<span class="string">"   |"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//        关闭资源</span></span><br><span class="line">        <span class="comment">/*释放结果集资源*/</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        <span class="comment">/*释放SQL执行者对象资源*/</span></span><br><span class="line">        preparedStatement.close();</span><br><span class="line">        <span class="comment">/*关闭连接*/</span></span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>使用PreparedStament的好处<ul><li>能预编译,加快执行速度</li><li>能防止SQL注入(不代表完全安全)</li><li>能将SQL参数化 操作起来更方便</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC基础操作</title>
      <link href="/2023/09/05/JavaWeb/JDBC%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/09/05/JavaWeb/JDBC%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="获取驱动Jar包"><a href="#获取驱动Jar包" class="headerlink" title="获取驱动Jar包"></a>获取驱动Jar包</h1><p><a href="https://downloads.mysql.com/archives/c-j/">MySQL :: Download MySQL Connector/J (Archived Versions)</a></p><p><img src="/JDBC%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.assets/dbfb1f5b-8189-4ab8-8ee5-338a2a1f39aa.png" alt="image.png"></p><span id="more"></span><h1 id="将Jar包作为依赖"><a href="#将Jar包作为依赖" class="headerlink" title="将Jar包作为依赖"></a>将Jar包作为依赖</h1><ul><li>打开项目结构</li></ul><p><img src="/JDBC%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.assets/674231a0-5223-4880-9be3-6fe5b538b1ed.png" alt="image.png"></p><ul><li>选择要导入的模块并选择要导入jar包类型的依赖</li></ul><p><img src="/JDBC%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.assets/5ae9c8e7-6801-4ed2-8a38-9e80ba446745.png" alt="image.png"></p><ul><li>选择依赖</li></ul><p><img src="/JDBC%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.assets/41663b81-6d08-45d3-bca3-96976262c9e4.png" alt="image.png"></p><h1 id="编写JDBC程序的基本步骤"><a href="#编写JDBC程序的基本步骤" class="headerlink" title="编写JDBC程序的基本步骤"></a>编写JDBC程序的基本步骤</h1><ul><li>加载并注册驱动 Driver类</li><li>获取数据库连接</li><li>获取SQL执行者 Stament对象</li><li>执行SQL语句</li><li>获取结果集合</li><li>释放连接资源</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="property">sql</span>.*;</span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">TestJDBC</span> {</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="title class_">String</span>[] args) throws <span class="title class_">ClassNotFoundException</span>, <span class="title class_">SQLException</span> {</span><br><span class="line"><span class="comment">//        加载数据库驱动</span></span><br><span class="line">        <span class="title class_">Class</span>.<span class="title function_">forName</span>(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">//       进行数据的连接</span></span><br><span class="line"><span class="comment">//        设置连接参数</span></span><br><span class="line">        <span class="title class_">String</span> url = <span class="string">"jdbc:mysql://localhost:3306/chapter01"</span>;</span><br><span class="line"><span class="comment">//这里的chapter01指的是数据库名称</span></span><br><span class="line">        <span class="title class_">String</span> user = <span class="string">"root"</span>;</span><br><span class="line">        <span class="title class_">String</span> password = <span class="string">"Xi233"</span>;</span><br><span class="line"><span class="comment">//                创建数据库连接</span></span><br><span class="line">        <span class="title class_">Connection</span> conn = <span class="title class_">DriverManager</span>.<span class="title function_">getConnection</span>(url, user, password);</span><br><span class="line"><span class="comment">//                  创建Statement对象用于向数据库发送SQL语句</span></span><br><span class="line">        <span class="title class_">Statement</span> statement = conn.<span class="title function_">createStatement</span>();</span><br><span class="line"><span class="comment">//                  要执行的SQL语句</span></span><br><span class="line">        <span class="title class_">String</span> selectSql = <span class="string">"select * from student;"</span>;</span><br><span class="line"><span class="comment">//          创建Result对象用来保存结果集</span></span><br><span class="line">        <span class="title class_">ResultSet</span> resultSet;</span><br><span class="line"><span class="comment">//           执行查询操作</span></span><br><span class="line">        resultSet = statement.<span class="title function_">executeQuery</span>(selectSql);</span><br><span class="line"><span class="comment">//        如果结果集合中有下一行数据就继续执行</span></span><br><span class="line">        <span class="keyword">while</span> (resultSet.<span class="title function_">next</span>()) {</span><br><span class="line"><span class="comment">//            根据属性获取对应的记录</span></span><br><span class="line">            int id = resultSet.<span class="title function_">getInt</span>(<span class="string">"sid"</span>);</span><br><span class="line">            <span class="title class_">String</span> name = resultSet.<span class="title function_">getString</span>(<span class="string">"sname"</span>);</span><br><span class="line">            <span class="title class_">String</span> course = resultSet.<span class="title function_">getString</span>(<span class="string">"course"</span>);</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(id + <span class="string">"|"</span> + name + <span class="string">"|"</span> + course);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"><span class="comment">//        关闭资源</span></span><br><span class="line">        <span class="comment">/*释放结果集资源*/</span></span><br><span class="line">        resultSet.<span class="title function_">close</span>();</span><br><span class="line">        <span class="comment">/*释放SQL执行者对象资源*/</span></span><br><span class="line">        statement.<span class="title function_">close</span>();</span><br><span class="line">        <span class="comment">/*关闭连接*/</span></span><br><span class="line">        conn.<span class="title function_">close</span>();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h1><h2 id="时区设置问题"><a href="#时区设置问题" class="headerlink" title="时区设置问题"></a>时区设置问题</h2><blockquote><p>The server time zone value ‘ÖÐ¹ú±ê×¼Ê±¼ä’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.</p></blockquote><h3 id="问题产生原因"><a href="#问题产生原因" class="headerlink" title="问题产生原因"></a>问题产生原因</h3><ul><li>连接数据库时没有设置好时区</li><li>默认设置的时区有问题</li></ul><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>解决办法1</strong></p><ul><li>连接数据库时设置时区参数</li></ul><p>在连接数据库的URL后加上</p><blockquote><p>?serverTimezone=UTC</p></blockquote><p><img src="/JDBC%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.assets/48754ed3-4b1f-4d3f-b168-a5d5126e76e8.png" alt="image.png"></p><p><strong>解决办法2</strong></p><ul><li>设置数据的中的默认时区</li></ul><p><img src="/JDBC%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.assets/04bd4517-95ba-4995-a73a-a8a7de51e012.png" alt="image.png"></p><blockquote><p>这样设置了之后就不用在连接时设置时区了</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>使用JDBC连接到数据库时需要导入数据库厂商提供的驱动(jar包形式)</li><li>编写JDBC程序的基本步骤为<ul><li>加载数据库驱动</li><li>注册驱动</li><li>获取连接</li><li>获取SQL执行者对象</li><li>使用SQL执行者对象执行SQL语句</li><li>使用ResultSet对象操作结果集合(使用next()判断下一条记录释是否存在)</li><li>释放资源(注意先后顺序 结果集→SQL执行者对象→连接对象)</li></ul></li><li>连接数据库时可能因为没设置时区而报错<ul><li>可以设置数据库的URL时加上时区参数</li><li>也可以直接到给数据库中设置默认的时区(设置完成就不用在URL中添加时区参数了)</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.5 JDBC URL</title>
      <link href="/2023/09/04/JavaWeb/1-5-JDBC-URL/"/>
      <url>/2023/09/04/JavaWeb/1-5-JDBC-URL/</url>
      
        <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li>表示数据库的用的</li></ul><blockquote><p>网站由网址作为表示 对于数据库而言也由对应的URL作为标识</p></blockquote><h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><img src="1-5-JDBC-URL.assets/image-20230904220531933.png" alt="image-20230904220531933"><span id="more"></span><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p><a href="https://dev.mysql.com/doc/connector-j/8.1/en/connector-j-reference-jdbc-url-format.html">https://dev.mysql.com/doc/connector-j/8.1/en/connector-j-reference-jdbc-url-format.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.4 JDBC常用API概述</title>
      <link href="/2023/09/04/JavaWeb/1-4-JDBC%E5%B8%B8%E7%94%A8API/"/>
      <url>/2023/09/04/JavaWeb/1-4-JDBC%E5%B8%B8%E7%94%A8API/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Driver接口"><a href="#1-Driver接口" class="headerlink" title="1.Driver接口"></a>1.Driver接口</h1><ul><li>所有JDBC驱动必须实现的接口(数据库厂商来实现)</li></ul><hr><p><strong>Q:主要是用来干嘛的?</strong></p><p>A:用来装在驱动的</p><p>可以通过java.lang.Class中的forName()来<strong>装载</strong>驱动</p><hr><h1 id="2-DriverManager接口"><a href="#2-DriverManager接口" class="headerlink" title="2.DriverManager接口"></a>2.DriverManager接口</h1><ul><li><strong>加载</strong>JDBC驱动的</li></ul><blockquote><p>使用registerDriver()注册驱动程序 (和formName的功能相同)</p></blockquote><ul><li>用来建立连接的</li></ul><blockquote><p>使用getConection()来获取和数据库的连接</p></blockquote><span id="more"></span><h1 id="3-Connection接口"><a href="#3-Connection接口" class="headerlink" title="3.Connection接口"></a>3.Connection接口</h1><ul><li>用来完成和数据库进行<strong>交互</strong>的</li></ul><blockquote><p>给数据库发送SQL对象的</p></blockquote><h1 id="4-Statment接口"><a href="#4-Statment接口" class="headerlink" title="4.Statment接口"></a>4.Statment接口</h1><ul><li>执行SQL语句的</li></ul><h1 id="5-PreparedStament接口"><a href="#5-PreparedStament接口" class="headerlink" title="5.PreparedStament接口"></a>5.PreparedStament接口</h1><ul><li>也是执行SQL语句的(执行的是预编译的SQL语句)</li><li>继承自Stament接口</li></ul><h1 id="6-CallableStament接口"><a href="#6-CallableStament接口" class="headerlink" title="6.CallableStament接口"></a>6.CallableStament接口</h1><ul><li>用来调用SQL的存储过程的</li><li>继承自PreparedStament接口</li></ul><h1 id="7-ResultSet-接口"><a href="#7-ResultSet-接口" class="headerlink" title="7.ResultSet 接口"></a>7.ResultSet 接口</h1><ul><li>用来执行select语句获得的结果集的(操作结果集的)</li><li>操作结果集合中的行</li></ul><blockquote><p>ResultSet中维护了一个指针指针<strong>默认在第一行之间前</strong>使用next() 或者previous()方法可以移动指针 指向具体的数据库行</p></blockquote><h1 id="8-ResultMetaData接口"><a href="#8-ResultMetaData接口" class="headerlink" title="8.ResultMetaData接口"></a>8.ResultMetaData接口</h1><ul><li>操作结果集用的</li><li>操作结果集中的列</li></ul><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/sql/package-summary.html">https://docs.oracle.com/javase/8/docs/api/java/sql/package-summary.html</a></p><p><a href="https://dev.mysql.com/doc/connector-j/8.1/en/">https://dev.mysql.com/doc/connector-j/8.1/en/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.2因特网概述</title>
      <link href="/2023/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2%E5%9B%A0%E7%89%B9%E7%BD%91%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.2%E5%9B%A0%E7%89%B9%E7%BD%91%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="网络、互联网、因特网"><a href="#网络、互联网、因特网" class="headerlink" title="网络、互联网、因特网"></a>网络、互联网、因特网</h1><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>   由节点(Node)和链接节点的链路(Link)组成</p><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/fbea496d-b0c0-413d-9251-0a436c0ecab4/7583af1a-1624-4f10-a387-07b853691b1f" alt="image.png"></p><span id="more"></span><h2 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h2><ul><li>网络的网络,多个网络通过路由器互联起来构成的</li></ul><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/fbea496d-b0c0-413d-9251-0a436c0ecab4/efa2b7e5-ed8b-4b47-b6cf-e6e92f47128d" alt="image.png"></p><h2 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h2><ul><li>本质是互联网</li><li>世界上最大的互联网</li></ul><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/fbea496d-b0c0-413d-9251-0a436c0ecab4/dc3f4a31-1d40-49b5-abe5-cf9c0cbfe7ea" alt="image.png"></p><blockquote><p>因特网非常庞大所以将其抽象成云 只要连上因特网的设备被称为主机就行</p></blockquote><h1 id="internet和Internet"><a href="#internet和Internet" class="headerlink" title="internet和Internet"></a>internet和Internet</h1><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/fbea496d-b0c0-413d-9251-0a436c0ecab4/7c0714da-5b35-4ba3-aa03-cbec6643b61c" alt="image.png"></p><p><strong>internet</strong></p><blockquote><p>通用名词</p><p>泛指计算机网络互联成的网络</p></blockquote><p><strong>Internet</strong></p><blockquote><p>全球最大的互联网</p><p>使用TCP/IP协议族作为通信规则</p></blockquote><h1 id="计算机网络的三个发展阶段"><a href="#计算机网络的三个发展阶段" class="headerlink" title="计算机网络的三个发展阶段"></a>计算机网络的三个发展阶段</h1><h2 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h2><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/fbea496d-b0c0-413d-9251-0a436c0ecab4/d56856b1-56bc-4e2e-aa4f-7d1db1c8a0f3" alt="image.png"></p><p><strong>大致过程</strong></p><p><strong>单</strong>个网络→三级结构的因特网→多层ISP结构的因特网</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p>   因特网服务提供者(能提供网络服务的公司)</p><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/fbea496d-b0c0-413d-9251-0a436c0ecab4/a3acd8ae-0d44-4dc7-b675-2f2a2cb3ac59" alt="image.png"></p><h3 id="基于ISP的三层结构网络"><a href="#基于ISP的三层结构网络" class="headerlink" title="基于ISP的三层结构网络"></a>基于ISP的三层结构网络</h3><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/fbea496d-b0c0-413d-9251-0a436c0ecab4/145746ee-aaf4-4edc-8159-24f98b6eb3bb" alt="image.png"></p><blockquote><p>普通用户接入到因特网也可以成为ISP,只要使用路由器让其他用户与其相连就行</p></blockquote><h1 id="因特网的标准化工作"><a href="#因特网的标准化工作" class="headerlink" title="因特网的标准化工作"></a>因特网的标准化工作</h1><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/fbea496d-b0c0-413d-9251-0a436c0ecab4/89aab44e-23ec-422a-ba7a-5d391fb887d0" alt="image.png"></p><p>因特网协会ISOC 负责管理因特网</p><p><strong>特点</strong></p><ul><li>指定标准面向公众</li></ul><h1 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h1><ul><li>核心部分</li></ul><blockquote><p>主要由路由器和网络组成 主要负责是分组转发(路由器的职能)</p></blockquote><ul><li>边缘部分</li></ul><blockquote><p>连接在因特网上的各种主机</p></blockquote><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/fbea496d-b0c0-413d-9251-0a436c0ecab4/0848f62d-4b19-413f-9de6-0497f5a43836" alt="image.png"></p><blockquote><p>路由器是专用计算机 但能称之为主机</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>结点+链路→网络</p><p>网络+网络→互联网</p><p>世界上最大的互联网→因特网</p><hr><p>internet和Internet</p><p>前者泛指由网络构成的互联网</p><p>后者使用TCP/IP协议族作为通信规则的互联网</p><hr><p>单个网络→三级结构互联网→多层次ISP因特网</p><p>因特网诞生时间=TCP/IP协议族成为标准=1983年、</p><hr><p>ISP:网络服务提供商(联通、移动、电信)</p><p>个人用户需要向ISP缴纳费用才能使用因特网</p><hr><p>因特网=核心部分(分组交换)+边缘部分(主机设备)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.3.2计算机网络性能指标(时延带宽积、往返时间、丢包率)</title>
      <link href="/2023/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.3.2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87(%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF%E3%80%81%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4%E3%80%81%E4%B8%A2%E5%8C%85%E7%8E%87)/"/>
      <url>/2023/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.3.2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87(%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF%E3%80%81%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4%E3%80%81%E4%B8%A2%E5%8C%85%E7%8E%87)/</url>
      
        <content type="html"><![CDATA[<h1 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>时延(传播时延)和带宽的乘积</p><p>时延带宽积=传播时延x带宽</p><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/0ab7a122-52a5-45fb-bcfb-b0b68e93e0c7/9c13eef3-c266-497b-bf96-067ccdba9f69" alt="image.png"></p><p>当第一个bit到达时 能通过时延带宽积得知当前链路中有多少个bit</p><blockquote><p>参考</p><p><a href="https://blog.csdn.net/ahLOG/article/details/116202211">【计算机网络】时延带宽积的理解（图解易懂）_GPNU_Log的博客-CSDN博客</a></p></blockquote><h1 id="往返时间-RTT"><a href="#往返时间-RTT" class="headerlink" title="往返时间(RTT)"></a>往返时间(RTT)</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>网络中信息双向交互的时间</p><ul><li>开始时间:源主机发送分组时</li><li>结束时间:源主机收到目的主机确认分组信息的时间</li></ul><blockquote><p>从目的主机出发再原路返回所需要的时间</p></blockquote><hr><p>Q:分组发送过程中在哪里的耗时最多?为什么?</p><p>A:卫星链路,其最长带来的带来的<strong>传播时延最长</strong></p><hr><span id="more"></span><h1 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>利用率</p><ul><li>信道利用率:信道有数据通过的所占百分比</li><li>网络利用率:全网络信道利用率加权平均</li></ul><hr><p><strong>排队理论</strong></p><p>信道利用与增加→时延增加大</p><blockquote><p>利用率不是越大越好</p></blockquote><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/0ab7a122-52a5-45fb-bcfb-b0b68e93e0c7/83c1e093-45c9-4229-9b7e-dfa8f7d298a1" alt="image.png"></p><blockquote><p>利用率不能太低(浪费资源)也不能太高(时延大)</p></blockquote><h1 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>分组丢包:在一定时间范围内(丢失分组数)/分组总数</p><h2 id="分组丢失的两种情况"><a href="#分组丢失的两种情况" class="headerlink" title="分组丢失的两种情况"></a>分组丢失的两种情况</h2><ul><li>传输过程中产生误码–被节点丢弃</li><li>所到达的分组交换机已经满-</li></ul><blockquote><p>不同的</p></blockquote><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/0ab7a122-52a5-45fb-bcfb-b0b68e93e0c7/74f5e225-dc6e-4509-8aab-87920b6bf7f2" alt="image.png"></p><h2 id="丢包的分类"><a href="#丢包的分类" class="headerlink" title="丢包的分类"></a>丢包的分类</h2><p>分组在的传输过程中经过很多地方所以可能产生丢包的地方较多</p><ul><li>接口丢包</li><li>节点丢包</li><li>路径丢包</li><li>网络丢包</li></ul><p>运维人员比较关心丢包一般用户感觉不到丢包</p><ul><li>丢包率反映了网络的拥塞状况</li></ul><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/0ab7a122-52a5-45fb-bcfb-b0b68e93e0c7/2f97b386-96d2-4f95-ad7e-518efe36fee5" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期传递问题</title>
      <link href="/2023/08/23/SpringBoot/%E6%97%A5%E6%9C%9F%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/23/SpringBoot/%E6%97%A5%E6%9C%9F%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>前端发来的日期格式和后端不匹配</p><ul><li>后端成员变量的时间属性是<strong>Date类型</strong></li></ul><p>默认的格式长这样<code>Jan 01 00:00:00 CST 2021</code></p><ul><li>前端发来的日记是<strong>字符串类型</strong></li></ul><p>格式是yyyy-MM-dd</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h2 id="解析并转换前端和日期格式"><a href="#解析并转换前端和日期格式" class="headerlink" title="解析并转换前端和日期格式"></a>解析并转换前端和日期格式</h2><ul><li>将前端发来的字符串类型的日期进行解析</li><li>转换成Date类型再进行赋值</li></ul><span id="more"></span><h1 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h1><h2 id="DateTimeFormat"><a href="#DateTimeFormat" class="headerlink" title="@DateTimeFormat"></a>@DateTimeFormat</h2><ul><li><p>功能</p><p> 解析前端发来的日期格式</p></li><li><p>用法</p><p> @DateTimeFormat(pattern = “解析的日期格式”)</p></li><li><p>注意点</p></li></ul><p>该注解只具有解析的作用并不具有格式转换的功能</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd"</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="JsonFormat"><a href="#JsonFormat" class="headerlink" title="@JsonFormat"></a>@JsonFormat</h2><ul><li><p>功能</p><p> 约束响应格式</p></li><li><p>用法</p></li></ul><p>@JsonFormat(pattern = (“响应的日期格式类型”）</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd"</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/8ea49bd2-48b8-4557-8882-2e6d27ec1c56/d97f0729-09ff-46c7-a75b-df7cc55d9e52" alt="image.png"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>对于前后端日期时间一致问题可以使用@JsonFormat和@DateTimeFormat进行解决</li><li>@DateTimeFormat用来解析前端发来的日期格式</li><li>@JsonFormat用来约束后端响应的格式</li><li>@DateTimeFormat只能解析指定日期各格式并不具备日期格式转换功能</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/zhuzicc/article/details/106529485">@JsonFormat 和 @DateTimeFormat 时间格式化注解详解（不看血亏）_jsonformat注解_zhuzicc的博客-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中的分层</title>
      <link href="/2023/08/22/SpringBoot/SpringBoot%E4%B8%AD%E7%9A%84%E5%88%86%E5%B1%82/"/>
      <url>/2023/08/22/SpringBoot/SpringBoot%E4%B8%AD%E7%9A%84%E5%88%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="最主要的几个分层"><a href="#最主要的几个分层" class="headerlink" title="最主要的几个分层"></a>最主要的几个分层</h1><blockquote><p>对于同一个层来说有不同的称呼只需要知道其作用即可不要纠结用哪个名称</p></blockquote><ul><li>数据库实体层(和数据库对应的)<ul><li>model层</li><li>entity层</li><li>pojo层</li></ul></li><li>数据持久层(访问数据库执行增删查改的)<ul><li>dao层</li><li>mapper层</li></ul></li><li>业务逻辑层(完成基本的功能设计)<ul><li>service层</li></ul></li><li>控制层(请求和响应控制)<ul><li>controller层</li></ul></li></ul><span id="more"></span><h1 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h1><p>   位于数据库实体层,用来实现<strong>层与层之间的数据</strong>传递</p><hr><blockquote><p>Q:不是有和数据库对应的实体了吗为什么还要DTO?</p></blockquote><blockquote><p>A:DTO更注重数据,在层与层之间所传递的数据可能并不需要传递整个实体的所有字段</p></blockquote><blockquote><p>另一方面DTO和数据库中的实体形成映射关系可以进行解耦</p></blockquote><hr><ul><li>不同的分层可能有不同的称呼,但本质还是描述同一个层</li><li>DTO层用与各层之间的数据传递</li><li>主要的是有以下几个分层<ul><li>数据库实体层-和数据库中的表对应-model</li><li>数据持久层-操作数据库用的-mapper</li><li>业务逻辑层-实现业务逻辑的-service</li><li>控制层-负责处理请求和响应的、写接口的-controller</li></ul></li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/cxy2020/p/12332505.html">Java DTO（data transfer object）的理解 - Code2020 - 博客园 (cnblogs.com)</a></p><p>?descriptionFromFileType=function+toLocaleUpperCase()+{+[native+code]+}+File&amp;mimeType=application/octet-stream&amp;fileName=SpringBoot中的分层.md&amp;fileType=undefined&amp;fileExtension=md</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.3.1计算机网络的性能指标(速率、带宽、吞吐量、时延)</title>
      <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.3.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87(%E9%80%9F%E7%8E%87%E3%80%81%E5%B8%A6%E5%AE%BD%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F%E3%80%81%E6%97%B6%E5%BB%B6)/"/>
      <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.3.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87(%E9%80%9F%E7%8E%87%E3%80%81%E5%B8%A6%E5%AE%BD%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F%E3%80%81%E6%97%B6%E5%BB%B6)/</url>
      
        <content type="html"><![CDATA[<h1 id="比特-bit"><a href="#比特-bit" class="headerlink" title="比特(bit)"></a>比特(bit)</h1><ul><li>计算机<strong>数据量的单位</strong></li><li>一个bit就是一个二进制数中的一个0或者1</li></ul><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/f620d9cd-7569-434a-8cea-f8ebf7d77d1a/55a259fc-90a4-4d89-99e3-2a65db3f84d1" alt="image.png"></p><p><strong>K M G T 各级相差2^10(标识存储10)</strong></p><blockquote><p>操作系统中的G和硬盘厂家的G</p><p>操作系统中的G=2^30</p><p>硬盘厂家的G=10^9</p></blockquote><h1 id="速率-比特率、数据率"><a href="#速率-比特率、数据率" class="headerlink" title="速率(比特率、数据率)"></a>速率(比特率、数据率)</h1><ul><li>网络中的主机属性信号上传递bit的速率</li></ul><blockquote><p>网络中传递bit的速度</p></blockquote><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/f620d9cd-7569-434a-8cea-f8ebf7d77d1a/6b950f80-1118-4a73-b2fb-b6d34618cf85" alt="image.png"></p><ul><li>K是使用的是小写</li><li>各级之间相差10^3和标识存储时的不同(2^10)</li><li>我们一般所认知的计量大小一致(M→ 兆)</li></ul><span id="more"></span><h2 id="存储单位和速率单位的对比"><a href="#存储单位和速率单位的对比" class="headerlink" title="存储单位和速率单位的对比"></a>存储单位和速率单位的对比</h2><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/f620d9cd-7569-434a-8cea-f8ebf7d77d1a/20c11e32-2162-4170-a4a7-168c0d550064" alt="image.png"></p><ul><li>进制不同<ul><li>存储时 除Byte外 其他进制都为2^10</li><li>表示速率时 进制则为10^3</li></ul></li><li>表示速率时使用k而不是k作为单位</li></ul><hr><ul><li>计算时的单位问题</li></ul><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/f620d9cd-7569-434a-8cea-f8ebf7d77d1a/83c8f9c5-8cd4-4536-97b7-886830f38fda" alt="image.png"></p><blockquote><p>由于表示存储和速率时的单位除了K和k不同之外 其余所使用的符号的都一样</p></blockquote><hr><blockquote><p>Q:既然符号都一样那是不是可以越掉?</p><p>A:严格意义上不同 因为二者所表示的的大小不同 不过对精度要求不高时可以越掉</p></blockquote><hr><h1 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h1><ul><li>通信线路能传递速率的能力</li><li>单位时间内从网络中某点到另一点能通过<strong>最高数据率(速率)</strong></li></ul><blockquote><p>网络中速率的峰值</p></blockquote><ul><li>单位和速率的相同</li></ul><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/f620d9cd-7569-434a-8cea-f8ebf7d77d1a/cc4ff758-ab1c-48ef-ae0e-9248b8819358" alt="image.png"></p><h1 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h1><ul><li>单位时间内 能通过某个网络的数据量</li><li>实际能有多少数据能通过(理论和实际往往不相符)</li><li>收到<strong>带宽、额定速率</strong>限制</li><li><strong>实际的带宽</strong></li></ul><blockquote><p><strong>因为收其他因素的的制约达不到理论的带宽→实际的带宽→吞吐量</strong></p></blockquote><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/f620d9cd-7569-434a-8cea-f8ebf7d77d1a/2175ddad-1c50-4133-a238-6ce2c1c53be2" alt="image.png"></p><h1 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h1><ul><li>在网络中数据从一个点到另外一个点的延时</li></ul><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/f620d9cd-7569-434a-8cea-f8ebf7d77d1a/a529ec7e-34e5-4e3f-b259-36ba1e7a8db0" alt="image.png"></p><ul><li>时延三个组成部分<ul><li>发送时延:主机发到网络中</li><li>传播时延:在网络中传播</li><li>处理时延:路由器分组转发(动态的 不方便计算)</li></ul></li></ul><blockquote><p>这里的处理时延包括的<strong>排队时延</strong></p></blockquote><hr><ul><li><strong>时延中谁是主导</strong></li></ul><blockquote><p>首先排除处理时延,因为是动态不好计算</p><p>不同的情况下主导方可能不同,所以需要具体问题具体分析</p></blockquote><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/f620d9cd-7569-434a-8cea-f8ebf7d77d1a/0b355b58-61c4-4718-b693-e210797afe70" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.5计算机网络分层的必要性</title>
      <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/"/>
      <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么分层"><a href="#为什么分层" class="headerlink" title="为什么分层"></a>为什么分层</h1><p>​在网络的实际应用中，需要解决各种不同的问题，因此需要使用不同的层来分别解决这些问题，并确保每个层都能够各司其职，便于管理。此外，还需要将各种问题进行拆分，分配到不同的层中去处理。</p><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/0add4ff3-c98c-4b40-9073-d162fa63fb5b/319915ce-ba5e-40cc-afe5-6495c2900aff" alt="image.png"></p><span id="more"></span><h1 id="物理层解决所解决的问题"><a href="#物理层解决所解决的问题" class="headerlink" title="物理层解决所解决的问题"></a>物理层解决所解决的问题</h1><p><strong>解决分组在两主机之间传输的问题</strong></p><ul><li>用什么物理接口？</li><li>用什么信号来表示bit?</li></ul><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/0add4ff3-c98c-4b40-9073-d162fa63fb5b/586d342a-aae9-48dd-aba9-21b4fe574fd1" alt="image.png"></p><h1 id="数据链路层所解决的问题"><a href="#数据链路层所解决的问题" class="headerlink" title="数据链路层所解决的问题"></a>数据链路层所解决的问题</h1><p><strong>解决分组在网络中传输的问题</strong></p><ul><li>如何标识各个主机?</li><li>怎么从数据流中区分地址和数据</li><li>争用总线问题如何解决?</li></ul><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/0add4ff3-c98c-4b40-9073-d162fa63fb5b/5ceff2b7-a7ce-42fb-8c3c-fe6257c6394f" alt="image.png"></p><h1 id="网络层所解决的问题"><a href="#网络层所解决的问题" class="headerlink" title="网络层所解决的问题"></a>网络层所解决的问题</h1><p><strong>解决分组在网络之间传输的问题</strong></p><ul><li>怎么标识各个网络</li><li>怎么标识网络中的主机</li><li>路由器怎么转发分组</li><li>如何进行路由选择(选什么路径进行转发分组?)</li></ul><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/0add4ff3-c98c-4b40-9073-d162fa63fb5b/d53fe8b0-86e5-4617-98d7-f0f96f42d648" alt="image.png"></p><h1 id="运输层所解决的问题"><a href="#运输层所解决的问题" class="headerlink" title="运输层所解决的问题"></a>运输层所解决的问题</h1><ul><li>得到的分组发给哪个应用(运输给谁)</li></ul><blockquote><p>主机收到了发来的分组QQ和浏览器都和网络通信相关的应用进程</p></blockquote><blockquote><p>这个分组是给谁的?</p></blockquote><ul><li>传递分组（运输过程中)出错了怎么办</li></ul><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/0add4ff3-c98c-4b40-9073-d162fa63fb5b/104bc4b4-da5a-4f62-8211-324c50bcca55" alt="image.png"></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>制定了各种协议(面向应用的)为不同应用程序指定了各种协议来进行开发</p><blockquote><p>要编写邮件相关的应用就按照SMTP协议</p></blockquote><blockquote><p>要搞文件传输就按照FTP协议</p></blockquote><p><img src="https://res.craft.do/user/full/1cf7cef4-ee3a-97e3-deb8-de111119df84/doc/0add4ff3-c98c-4b40-9073-d162fa63fb5b/68b6f2bb-47a3-41f0-a3b1-08ac164238c0" alt="image.png"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>网络在在使用过程中会产生众多问题 将各种问题进行拆分 交给不同的层进行解决</p><p>不同层各司其职、解决各自需要解决的问题</p><hr><p>Q:这么多问题之间用一个层或者干脆不分层全给他解决了不好吗</p><p>A:全放一块解决 会导致体系结构变得十分复杂、难以理解、难以维护</p><p>和写程序一样过多的功能(网络中问题的解决)写在一块会导致耦合性过高后期难以维护</p><hr><ul><li><strong>物理层</strong><ol><li>用什么样的信号标识bit</li><li>用什么样子的网络接口</li></ol></li><li><strong>数据链路层</strong><ol><li>怎么在<strong>一个网络</strong>中传输报文</li><li>怎么标识网络中的主机</li></ol></li><li><strong>网络层</strong><ol><li>怎么在<strong>各个网络</strong>之间传输报文</li><li>怎么标识各个网络和其中的主机</li></ol></li><li><strong>运输层</strong><ol><li>收到的报文应该给哪个进程(有网络通信相关进程应用)</li><li>报文运输过程中出现错误怎么办</li></ol></li><li><strong>应用层</strong><ol><li>制定了各种协议 为不同的应用</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件过程</title>
      <link href="/2023/07/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/07/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="软件过程-过程模型"><a href="#软件过程-过程模型" class="headerlink" title="软件过程(过程模型)"></a>软件过程(过程模型)</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>为了获取高质量软件所需要完成的一系列任务的框架,规定了完成各项任务的工作步骤</p><blockquote><p>为了能开发出高质量的软件 得按一定的开发流程来,所遵守的一整套流程被称之为软件过程(过程模型)</p></blockquote><ul><li><strong>ISO9000对软件过程的定义</strong></li></ul><p>使用资源将输入转换为输出的活动所构成的系统</p><blockquote><p>给定<strong>输入</strong>比如人员 需求,经过<strong>一系列过程</strong>得到输出即<strong>软件</strong></p><p>这里的一系列过程可以理解为软件过程</p></blockquote><span id="more"></span><h2 id="2-过程模型"><a href="#2-过程模型" class="headerlink" title="2.过程模型"></a>2.过程模型</h2><p>软件过程以软件生命周期为基础,</p><p><strong>但没有一个通用的软件过程</strong>能<strong>适用</strong>于<strong>所有类型的软件的开发</strong></p><p>因此开发不同的软件应根据软件的特点采用不同的软件过程(过程模型)</p><h2 id="3-常见的过程模型"><a href="#3-常见的过程模型" class="headerlink" title="3.常见的过程模型"></a>3.常见的过程模型</h2><p>1.瀑布模型</p><p>2.快速原型模型</p><p>3.增量模型</p><p>4.螺旋模型</p><p>5.喷泉模型</p><p>6.Rational统一过程</p><p>7.敏捷过程与极限编程</p><p>8.微软过程</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>软件过程是将输入(人员、需求)变为输出(满足需求的高质量软件)的过程</li><li>开发不同类型软件需要根据需要使用过程(过程模型) </li><li>软件过程也可以称之为过程模型</li><li>软件生命周期是最基本的过程模型</li><li>在生命周期的基础上进行优化扩充就可以得到不同的过程模型</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String StringBuffer StringBuilder</title>
      <link href="/2023/06/29/Java/String-StringBuffer-StringBuilder/"/>
      <url>/2023/06/29/Java/String-StringBuffer-StringBuilder/</url>
      
        <content type="html"><![CDATA[<h1 id="String-StringBuffer-StringBuilder"><a href="#String-StringBuffer-StringBuilder" class="headerlink" title="String StringBuffer StringBuilder"></a>String StringBuffer StringBuilder</h1><h2 id="为什么要区分这么多的字符串类"><a href="#为什么要区分这么多的字符串类" class="headerlink" title="为什么要区分这么多的字符串类"></a>为什么要区分这么多的字符串类</h2><blockquote><p>字符串是使用最为频繁的数据类型之一</p><p>有的字符串需要经常修改 、有的的不需要</p><p>有时需要处理大量字符、有时只要处理少量的字符串</p></blockquote><p><strong>根据操作的不同特点 使用不同的的字符串类型</strong></p><h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><ul><li>都是字符串类</li><li>都是用来处理字符串的</li></ul><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><h3 id="执行速度"><a href="#执行速度" class="headerlink" title="执行速度"></a>执行速度</h3><p>StringBuilder &gt;StringBuffer&gt;String</p><span id="more"></span><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>String -线程安全</p><p>StringBuffer -线程安全</p><p>StringBuilder-线程不安全</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><ul><li><p>大量</p><ul><li>单线程-StringBuilder</li><li>多线程-StringBuffer</li></ul></li><li><p>少量</p><ul><li>String</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口和抽象类</title>
      <link href="/2023/06/29/Java/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
      <url>/2023/06/29/Java/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h1><h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><ul><li>都能实现多态</li><li>都能增加代码的重用性</li></ul><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><h3 id="作用方面"><a href="#作用方面" class="headerlink" title="作用方面"></a>作用方面</h3><ul><li><p>接口(只定义方法 不进行实现)</p><ul><li><p>定义了公共方法和常量 没有具体的实现</p><blockquote><p>实现接口的类叫做实现类 必须实现全部方法</p></blockquote></li></ul></li><li><p>抽象类(本质还是一个类 其中写了抽象方法)</p><ul><li><p>可以包含抽象方法和非抽象方法</p><blockquote><p>对应的实现方法可以选择 部分实现或者全部实现</p></blockquote></li></ul></li></ul><span id="more"></span><h3 id="多继承和支持"><a href="#多继承和支持" class="headerlink" title="多继承和支持"></a>多继承和支持</h3><ul><li><p>接口</p><ul><li><p>支持多继承</p><blockquote><p>一个类可以实现多个接口</p></blockquote></li></ul></li><li><p>抽象类</p><ul><li><p>一个类只能实现一个抽象类</p><blockquote><p>因为本质是类 且 类具有单继承的机制</p></blockquote></li></ul></li></ul><!-- more --><h3 id="类型方面"><a href="#类型方面" class="headerlink" title="类型方面"></a>类型方面</h3><ul><li>接口 –&gt; 引用型数据类型</li><li>抽线类–&gt; 类</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
